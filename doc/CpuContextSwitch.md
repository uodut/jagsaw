> 大量等待CPU的进程调度也会导致平均负载升高，此时的CPU使用率也会升高。CPU的进程调度为什么会导致平均负载升高呢？

进程在竞争CPU的时候并没有真正运行，为什么还会导致系统的负载升高呢？==CPU上下文切换就是罪魁祸首==

我们都知道，Linux是一个多任务操作系统，它支持远大于CPU数量的任务同时运行。当然，这些任务并不是真正的同时运行，而是因为系统在很短的时间内，将==CPU轮流分配==给它们，造成多任务同时运行的错觉。

而在每个任务运行前，CPU都需要知道任务从哪里加载、又在哪里开始运行，也就是说，需要系统事先帮它设置好 **CPU寄存器和程序计数器**。

CPU寄存器，是CPU内置的容量小、但速度极快的内存。而程序计数器，则是用来存储CPU正在执行的指令位置、或者即将执行的下一条指令位置。它们都是CPU在运行任何任务前必须的依赖环境，**因此也被叫做CPU上下文。**

CPU上下文切换：就是先把前一个任务的CPU上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。

> CPU上下文切换无非就是更新了CPU寄存器的值，但这些寄存器，本身就是为了快速运行任务而设计的，为什么会影响系统的CPU性能呢？

在回答这个问题前，不知道你有没有想过，操作系统管理的这些"任务"到底是什么呢？

也许你会说，任务就是进程，或者说任务就是线程。是的，进程和线程是最常见的任务。但是除此之外呢？还有没有其他的任务呢？ **硬件通过触发信号，会导致中断程序的调用，也是一种常见的任务**

所以 <font color=red >根据任务的不同</font>,CPU的上下文切换就可以分为几个不同的场景，也就是 **进程上下文切换**、**线程上下文切换**以及**中断上下文切换**。

>怎么理解这几个不同的上下文切换，以及它们为什么会引发CPU性能相关问题呢？

### 进程上下文切换
Linux按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中，CPU特权等级的Ring0和Ring3。
- 内核空间（Ring0）具有最高权限，可以直接访问所有资源
- 用户空间（Ring3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。

![github](https://upload.cc/i1/2018/11/28/gnEYIw.png "github")